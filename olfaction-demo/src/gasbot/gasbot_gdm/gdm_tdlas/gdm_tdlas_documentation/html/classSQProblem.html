<title>gdm_tdlas: SQProblem Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SQProblem Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="SQProblem" --><!-- doxytag: inherits="QProblem" -->
<p>Implements the online active set strategy for QPs with varying matrices.  
 <a href="classSQProblem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SQProblem_8hpp_source.html">SQProblem.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SQProblem:</div>
<div class="dyncontent">
<div class="center"><img src="classSQProblem__inherit__graph.png" border="0" usemap="#SQProblem_inherit__map" alt="Inheritance graph"/></div>
<map name="SQProblem_inherit__map" id="SQProblem_inherit__map">
<area shape="rect" id="node2" href="classQProblem.html" title="Implements the online active set strategy for QPs with general constraints." alt="" coords="9,83,89,112"/><area shape="rect" id="node4" href="classQProblemB.html" title="Implements the online active set strategy for box&#45;constrained QPs." alt="" coords="5,5,93,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classSQProblem-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#ae857262f55e360c3e1e4295c8d713270">hotstart</a> (const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const H_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const g_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const A_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ubA_new, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#af99c2e4c5473e9617d08382c6d5bf44f">hotstart</a> (<a class="el" href="classSymmetricMatrix.html">SymmetricMatrix</a> *H_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const g_new, <a class="el" href="classMatrix.html">Matrix</a> *A_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ubA_new, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a2c3fb4cccdcb45bf4db67bd0cebf6e60">hotstart</a> (const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const g_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ubA_new, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime, const <a class="el" href="classBounds.html">Bounds</a> *const guessedBounds, const <a class="el" href="classConstraints.html">Constraints</a> *const guessedConstraints)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a722bf7dbc812e92bb696a7e5a0c47050">hotstart</a> (const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const g_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const ubA_new, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a08314bc34b07e91956e8abacd13b2315">hotstart</a> (const char *const g_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a0b60e7d63ff62e6222d8d2474b0d0bd6">hotstart</a> (const char *const H_file, const char *const g_file, const char *const A_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a75e77fc4849e362540980cdc34bef0cd">hotstart</a> (const char *const g_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const cputime, const <a class="el" href="classBounds.html">Bounds</a> *const guessedBounds, const <a class="el" href="classConstraints.html">Constraints</a> *const guessedConstraints)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSQProblem.html">SQProblem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#aa040a1957af3927e985b1cae3b1dff27">operator=</a> (const <a class="el" href="classSQProblem.html">SQProblem</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#aeb7c89d308a9805c6998c72a3c2e6a45">SQProblem</a> (int _nV, int _nC, <a class="el" href="Types_8hpp.html#a604cad5cda14e378ce4a77ab28ee9fd9">HessianType</a> _hessianType=HST_UNKNOWN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a720cfa87922b63bdee6679a72c773c8d">SQProblem</a> (const <a class="el" href="classSQProblem.html">SQProblem</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#ae1cb6ec33ca0ea3021688d4ed2971b50">SQProblem</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#a65cb28afd5651a23856c37f644155f31">~SQProblem</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#ae5cd3ceaf3dbcaf9e0754264c29ba266">setupAuxiliaryQP</a> (const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const H_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const A_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *ubA_new)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#aee7ddf9b36cb0e89d2252c8ac1fbe876">setupAuxiliaryQP</a> (<a class="el" href="classSymmetricMatrix.html">SymmetricMatrix</a> *H_new, <a class="el" href="classMatrix.html">Matrix</a> *A_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *lb_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *ub_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *lbA_new, const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *ubA_new)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSQProblem.html#ab55a166adacbc90da27a86b0010c81d7">SolutionAnalysis</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implements the online active set strategy for QPs with varying matrices. </p>
<p>A class for setting up and solving quadratic programs with varying QP matrices. The main feature is the possibily to use the newly developed online active set strategy for parametric quadratic programming.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Hans Joachim Ferreau, Andreas Potschka, Christian Kirches </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>3.0beta </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2007-2012 </dd></dl>

<p>Definition at line <a class="el" href="SQProblem_8hpp_source.html#l00059">59</a> of file <a class="el" href="SQProblem_8hpp_source.html">SQProblem.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae1cb6ec33ca0ea3021688d4ed2971b50"></a><!-- doxytag: member="SQProblem::SQProblem" ref="ae1cb6ec33ca0ea3021688d4ed2971b50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BEGIN_NAMESPACE_QPOASES SQProblem::SQProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. </p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00051">51</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb7c89d308a9805c6998c72a3c2e6a45"></a><!-- doxytag: member="SQProblem::SQProblem" ref="aeb7c89d308a9805c6998c72a3c2e6a45" args="(int _nV, int _nC, HessianType _hessianType=HST_UNKNOWN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQProblem::SQProblem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_nC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#a604cad5cda14e378ce4a77ab28ee9fd9">HessianType</a>&#160;</td>
          <td class="paramname"><em>_hessianType</em> = <code>HST_UNKNOWN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor which takes the QP dimension and Hessian type information. If the Hessian is the zero (i.e. HST_ZERO) or the identity matrix (i.e. HST_IDENTITY), respectively, no memory is allocated for it and a NULL pointer can be passed for it to the <a class="el" href="classQProblem.html#aa286539b43de9a08bc18a9d70c799008">init()</a> functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_nV</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">_nC</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">_hessianType</td><td>Type of Hessian matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00059">59</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a720cfa87922b63bdee6679a72c773c8d"></a><!-- doxytag: member="SQProblem::SQProblem" ref="a720cfa87922b63bdee6679a72c773c8d" args="(const SQProblem &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQProblem::SQProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSQProblem.html">SQProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor (deep copy). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rhs object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00067">67</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65cb28afd5651a23856c37f644155f31"></a><!-- doxytag: member="SQProblem::~SQProblem" ref="a65cb28afd5651a23856c37f644155f31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SQProblem::~SQProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00075">75</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae857262f55e360c3e1e4295c8d713270"></a><!-- doxytag: member="SQProblem::hotstart" ref="ae857262f55e360c3e1e4295c8d713270" args="(const real_t *const H_new, const real_t *const g_new, const real_t *const A_new, const real_t *const lb_new, const real_t *const ub_new, const real_t *const lbA_new, const real_t *const ubA_new, int &amp;nWSR, real_t *const cputime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>H_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>A_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ubA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> using online active set strategy. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_MATRIX_SHIFT_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_SETUP_AUXILIARYQP_FAILED </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">H_new</td><td>Hessian matrix of neighbouring QP to be solved. <br/>
 If Hessian matrix is trivial, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">g_new</td><td>Gradient of neighbouring QP to be solved. </td></tr>
    <tr><td class="paramname">A_new</td><td>Constraint matrix of neighbouring QP to be solved. <br/>
 If QP sequence does not involve constraints, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lb_new</td><td>Lower bounds of neighbouring QP to be solved. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_new</td><td>Upper bounds of neighbouring QP to be solved. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_new</td><td>Lower constraints' bounds of neighbouring QP to be solved. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_new</td><td>Upper constraints' bounds of neighbouring QP to be solved. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00097">97</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af99c2e4c5473e9617d08382c6d5bf44f"></a><!-- doxytag: member="SQProblem::hotstart" ref="af99c2e4c5473e9617d08382c6d5bf44f" args="(SymmetricMatrix *H_new, const real_t *const g_new, Matrix *A_new, const real_t *const lb_new, const real_t *const ub_new, const real_t *const lbA_new, const real_t *const ubA_new, int &amp;nWSR, real_t *const cputime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricMatrix.html">SymmetricMatrix</a> *&#160;</td>
          <td class="paramname"><em>H_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>A_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ubA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> using online active set strategy. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_MATRIX_SHIFT_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_SETUP_AUXILIARYQP_FAILED </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">H_new</td><td>Hessian matrix of neighbouring QP to be solved. <br/>
 If Hessian matrix is trivial, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">g_new</td><td>Gradient of neighbouring QP to be solved. </td></tr>
    <tr><td class="paramname">A_new</td><td>Constraint matrix of neighbouring QP to be solved. <br/>
 If QP sequence does not involve constraints, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lb_new</td><td>Lower bounds of neighbouring QP to be solved. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_new</td><td>Upper bounds of neighbouring QP to be solved. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_new</td><td>Lower constraints' bounds of neighbouring QP to be solved. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_new</td><td>Upper constraints' bounds of neighbouring QP to be solved. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00226">226</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e77fc4849e362540980cdc34bef0cd"></a><!-- doxytag: member="SQProblem::hotstart" ref="a75e77fc4849e362540980cdc34bef0cd" args="(const char *const g_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, real_t *const cputime, const Bounds *const guessedBounds, const Constraints *const guessedConstraints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>g_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lb_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ub_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lbA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ubA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBounds.html">Bounds</a> *const&#160;</td>
          <td class="paramname"><em>guessedBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraints.html">Constraints</a> *const&#160;</td>
          <td class="paramname"><em>guessedConstraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> (without matrix shift) using online active set strategy (using an initialised homotopy) reading QP data from files. Note: This functions just forwards to the corresponding <a class="el" href="classQProblem.html#ac4779ef92b0dda8a9dd283df2a910afc">QProblem::hotstart</a> member function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_WORKINGSET_UPDATE_FAILED <br/>
 RET_UNABLE_TO_READ_FILE </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_file</td><td>Name of file where gradient, of neighbouring QP to be solved, is stored. </td></tr>
    <tr><td class="paramname">lb_file</td><td>Name of file where lower bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_file</td><td>Name of file where upper bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_file</td><td>Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_file</td><td>Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
    <tr><td class="paramname">guessedBounds</td><td>Initial guess for working set of bounds. A null pointer corresponds to an empty working set! </td></tr>
    <tr><td class="paramname">guessedConstraints</td><td>Initial guess for working set of constraints. A null pointer corresponds to an empty working set! </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classQProblem.html#ab1c064ca7d61b33afa39e98311ea9f1f">QProblem</a>.</p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00318">318</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a722bf7dbc812e92bb696a7e5a0c47050"></a><!-- doxytag: member="SQProblem::hotstart" ref="a722bf7dbc812e92bb696a7e5a0c47050" args="(const real_t *const g_new, const real_t *const lb_new, const real_t *const ub_new, const real_t *const lbA_new, const real_t *const ubA_new, int &amp;nWSR, real_t *const cputime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ubA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> (without matrix shift) using online active set strategy. Note: This functions just forwards to the corresponding <a class="el" href="classQProblem.html#ac4779ef92b0dda8a9dd283df2a910afc">QProblem::hotstart</a> member function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>Gradient of neighbouring QP to be solved. </td></tr>
    <tr><td class="paramname">lb_new</td><td>Lower bounds of neighbouring QP to be solved. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_new</td><td>Upper bounds of neighbouring QP to be solved. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_new</td><td>Lower constraints' bounds of neighbouring QP to be solved. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_new</td><td>Upper constraints' bounds of neighbouring QP to be solved. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classQProblem.html#ac4779ef92b0dda8a9dd283df2a910afc">QProblem</a>.</p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00275">275</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c3fb4cccdcb45bf4db67bd0cebf6e60"></a><!-- doxytag: member="SQProblem::hotstart" ref="a2c3fb4cccdcb45bf4db67bd0cebf6e60" args="(const real_t *const g_new, const real_t *const lb_new, const real_t *const ub_new, const real_t *const lbA_new, const real_t *const ubA_new, int &amp;nWSR, real_t *const cputime, const Bounds *const guessedBounds, const Constraints *const guessedConstraints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>g_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>ubA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBounds.html">Bounds</a> *const&#160;</td>
          <td class="paramname"><em>guessedBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraints.html">Constraints</a> *const&#160;</td>
          <td class="paramname"><em>guessedConstraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> (without matrix shift) using online active set strategy (using an initialised homotopy). Note: This functions just forwards to the corresponding <a class="el" href="classQProblem.html#ac4779ef92b0dda8a9dd283df2a910afc">QProblem::hotstart</a> member function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_WORKINGSET_UPDATE_FAILED </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>Gradient of neighbouring QP to be solved. </td></tr>
    <tr><td class="paramname">lb_new</td><td>Lower bounds of neighbouring QP to be solved. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_new</td><td>Upper bounds of neighbouring QP to be solved. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_new</td><td>Lower constraints' bounds of neighbouring QP to be solved. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_new</td><td>Upper constraints' bounds of neighbouring QP to be solved. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
    <tr><td class="paramname">guessedBounds</td><td>Initial guess for working set of bounds. A null pointer corresponds to an empty working set! </td></tr>
    <tr><td class="paramname">guessedConstraints</td><td>Initial guess for working set of constraints. A null pointer corresponds to an empty working set! </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classQProblem.html#ac54d0d8ce4b025ec5d9eae3182b09687">QProblem</a>.</p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00303">303</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08314bc34b07e91956e8abacd13b2315"></a><!-- doxytag: member="SQProblem::hotstart" ref="a08314bc34b07e91956e8abacd13b2315" args="(const char *const g_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, real_t *const cputime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>g_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lb_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ub_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lbA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ubA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> (without matrix shift) using online active set strategy reading QP data from files. Note: This functions just forwards to the corresponding <a class="el" href="classQProblem.html#ac4779ef92b0dda8a9dd283df2a910afc">QProblem::hotstart</a> member function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_UNABLE_TO_READ_FILE </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">g_file</td><td>Name of file where gradient, of neighbouring QP to be solved, is stored. </td></tr>
    <tr><td class="paramname">lb_file</td><td>Name of file where lower bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_file</td><td>Name of file where upper bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_file</td><td>Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_file</td><td>Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classQProblem.html#a3dcfc9199ff2391c25fb5c7cfdcfd2f9">QProblem</a>.</p>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00289">289</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b60e7d63ff62e6222d8d2474b0d0bd6"></a><!-- doxytag: member="SQProblem::hotstart" ref="a0b60e7d63ff62e6222d8d2474b0d0bd6" args="(const char *const H_file, const char *const g_file, const char *const A_file, const char *const lb_file, const char *const ub_file, const char *const lbA_file, const char *const ubA_file, int &amp;nWSR, real_t *const cputime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::hotstart </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>H_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>g_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>A_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lb_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ub_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>lbA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ubA_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nWSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>cputime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solves an initialised <a class="el" href="classSQProblem.html" title="Implements the online active set strategy for QPs with varying matrices.">SQProblem</a> using online active set strategy reading QP data from files. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MAX_NWSR_REACHED <br/>
 RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED <br/>
 RET_HOTSTART_FAILED <br/>
 RET_MATRIX_SHIFT_FAILED <br/>
 RET_SHIFT_DETERMINATION_FAILED <br/>
 RET_STEPDIRECTION_DETERMINATION_FAILED <br/>
 RET_STEPLENGTH_DETERMINATION_FAILED <br/>
 RET_HOMOTOPY_STEP_FAILED <br/>
 RET_HOTSTART_STOPPED_INFEASIBILITY <br/>
 RET_HOTSTART_STOPPED_UNBOUNDEDNESS <br/>
 RET_SETUP_AUXILIARYQP_FAILED <br/>
 RET_UNABLE_TO_READ_FILE <br/>
 RET_INVALID_ARGUMENTS </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">H_file</td><td>Name of file where Hessian matrix is stored. <br/>
 If Hessian matrix is trivial, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">g_file</td><td>Name of file where gradient, of neighbouring QP to be solved, is stored. </td></tr>
    <tr><td class="paramname">A_file</td><td>Name of file where constraint matrix is stored. <br/>
 If QP sequence does not involve constraints, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lb_file</td><td>Name of file where lower bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ub_file</td><td>Name of file where upper bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">lbA_file</td><td>Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no lower constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">ubA_file</td><td>Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. <br/>
 If no upper constraints' bounds exist, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">nWSR</td><td>Input: Maximum number of working set recalculations; <br/>
 Output: Number of performed working set recalculations. </td></tr>
    <tr><td class="paramname">cputime</td><td>Input: Maximum CPU time allowed for QP solution. <br/>
 Output: CPU time spend for QP solution (or to perform nWSR iterations). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00140">140</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa040a1957af3927e985b1cae3b1dff27"></a><!-- doxytag: member="SQProblem::operator=" ref="aa040a1957af3927e985b1cae3b1dff27" args="(const SQProblem &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSQProblem.html">SQProblem</a> &amp; SQProblem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSQProblem.html">SQProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment operator (deep copy). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Rhs object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00083">83</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5cd3ceaf3dbcaf9e0754264c29ba266"></a><!-- doxytag: member="SQProblem::setupAuxiliaryQP" ref="ae5cd3ceaf3dbcaf9e0754264c29ba266" args="(const real_t *const H_new, const real_t *const A_new, const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::setupAuxiliaryQP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>H_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *const&#160;</td>
          <td class="paramname"><em>A_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>ubA_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets new matrices and calculates their factorisations. If the current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given, memory for Hessian is allocated and it is set to the given one. Afterwards, all QP vectors are transformed in order to start from an optimal solution. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MATRIX_FACTORISATION_FAILED <br/>
 RET_NO_HESSIAN_SPECIFIED </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">H_new</td><td>New Hessian matrix. <br/>
 If Hessian matrix is trivial, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">A_new</td><td>New constraint matrix. <br/>
 If QP sequence does not involve constraints, a NULL pointer can be passed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00350">350</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee7ddf9b36cb0e89d2252c8ac1fbe876"></a><!-- doxytag: member="SQProblem::setupAuxiliaryQP" ref="aee7ddf9b36cb0e89d2252c8ac1fbe876" args="(SymmetricMatrix *H_new, Matrix *A_new, const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="MessageHandling_8hpp.html#a81d556f613bfbabd0b1f9488c0fa865e">returnValue</a> SQProblem::setupAuxiliaryQP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricMatrix.html">SymmetricMatrix</a> *&#160;</td>
          <td class="paramname"><em>H_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>A_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>lb_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>ub_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>lbA_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Types_8hpp.html#acfbb1546e581bff0de2fa030397dc14d">real_t</a> *&#160;</td>
          <td class="paramname"><em>ubA_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets new matrices and calculates their factorisations. If the current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given, memory for Hessian is allocated and it is set to the given one. Afterwards, all QP vectors are transformed in order to start from an optimal solution. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESSFUL_RETURN <br/>
 RET_MATRIX_FACTORISATION_FAILED <br/>
 RET_NO_HESSIAN_SPECIFIED </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">H_new</td><td>New Hessian matrix. <br/>
 If Hessian matrix is trivial, a NULL pointer can be passed. </td></tr>
    <tr><td class="paramname">A_new</td><td>New constraint matrix. <br/>
 If QP sequence does not involve constraints, a NULL pointer can be passed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SQProblem_8cpp_source.html#l00372">372</a> of file <a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ab55a166adacbc90da27a86b0010c81d7"></a><!-- doxytag: member="SQProblem::SolutionAnalysis" ref="ab55a166adacbc90da27a86b0010c81d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSolutionAnalysis.html">SolutionAnalysis</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classQProblem.html#ab55a166adacbc90da27a86b0010c81d7">QProblem</a>.</p>

<p>Definition at line <a class="el" href="SQProblem_8hpp_source.html#l00062">62</a> of file <a class="el" href="SQProblem_8hpp_source.html">SQProblem.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SQProblem_8hpp_source.html">SQProblem.hpp</a></li>
<li><a class="el" href="SQProblem_8cpp_source.html">SQProblem.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<br clear="all" />
<hr size="1"><div style="align: right;">
<a href="http://ros.org/wiki/gdm_tdlas">gdm_tdlas</a><br />
Author(s): Victor Hernandez</br />
<small>autogenerated on Fri Jul 27 2012 16:09:57</small>
</div>
</body>
</html>
