
#include "cell.h"

using namespace std;
using namespace GdmTDLAS;

//==========================================================================================================
void Cell::print(){
/*	cout << "POS: " << this->x << " - " << this->y << " - " << this->z << endl;
	cout << "SIZE " << this->size << endl;
	cout << "COLOR " << this->r <<" - "<< this->g <<" - "<<this->b << endl;
	cout << "VERTICES" << endl;

	for (int i=0;i<8;i++){
		cout << "P" << i << ": " << this->vertex[i].x << " - " << this->vertex[i].y << " - " << this->vertex[i].z << endl;
	}*/
}	
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
Cell::Cell(float x, float y, float z, float size){
	this->x = x;
	this->y = y;	
	this->z = z;
	this->size = size;
	this->r = CELL_DEFAULT_R;
	this->g = CELL_DEFAULT_G;
	this->b = CELL_DEFAULT_B;
	this->conc = 0;
}
//---------------------------------------------------------------------------------------------------------
		
//==========================================================================================================
int Cell::setColor(float r, float g, float b){
	this->r=r;
	this->g=g;
	this->b=b;
	return 0;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
int Cell::setConcentration(float conc){
	this->conc = conc;
	return 0;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
float Cell::getConcentration(){
	return this->conc;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
float Cell::getX(){
	return this->x;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
float Cell::getY(){
	return this->y;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
float Cell::getZ(){
	return this->z;
}
//---------------------------------------------------------------------------------------------------------

//==========================================================================================================
void Cell::publish(pcl::PointCloud<pcl::PointXYZRGB> &point_cloud){
	
	point_cloud.width = round(this->conc * CELL_MAX_POINTS);
	point_cloud.height = 1;
	point_cloud.points.resize (point_cloud.width * point_cloud.height);
	
	for (size_t i = 0; i < point_cloud.points.size(); i++)
	{
	    point_cloud.points[i].x = this->x - this->size / 2.0 +  this->size * rand() / (RAND_MAX + 1.0f);
	    point_cloud.points[i].y = this->y - this->size / 2.0 +  this->size * rand() / (RAND_MAX + 1.0f);
	    point_cloud.points[i].z = this->z - this->size / 2.0 +  this->size * rand() / (RAND_MAX + 1.0f);
	    point_cloud.points[i].r = this->r*255;
            point_cloud.points[i].g = this->g*255;
            point_cloud.points[i].b = this->b*255;
	}
}
//---------------------------------------------------------------------------------------------------------

















